{
  "version": 3,
  "sources": ["../src/extensions.tsx", "../src/utils.ts", "../src/lib/cursor.ts", "../src/extension-actions.tsx"],
  "sourcesContent": ["import { Action, ActionPanel, Color, List, showToast, Toast } from \"@raycast/api\";\nimport { useState, useEffect } from \"react\";\nimport { getErrorMessage } from \"./utils\";\nimport type { Extension } from \"./lib/cursor\";\nimport { getLocalExtensions } from \"./lib/cursor\";\nimport {\n  OpenExtensionByIDInBrowserAction,\n  OpenExtensionByIDInCursorAction,\n  UninstallExtensionByIDAction,\n} from \"./extension-actions\";\n\nfunction OpenExtensionInCursorAction(props: { extension: Extension }): JSX.Element {\n  return <OpenExtensionByIDInCursorAction extensionID={props.extension.id} />;\n}\n\nfunction OpenExtensionInBrowserAction(props: { extension: Extension }): JSX.Element {\n  return <OpenExtensionByIDInBrowserAction extensionID={props.extension.id} />;\n}\n\nfunction ExtensionListItem(props: { extension: Extension; reloadExtension: () => void }): JSX.Element {\n  const e = props.extension;\n  return (\n    <List.Item\n      title={e.name}\n      subtitle={e.publisherDisplayName}\n      icon={{ source: e.icon || \"icon.png\", fallback: \"icon.png\" }}\n      accessories={[\n        {\n          tag: e.preview === true ? { color: Color.Red, value: \"Preview\" } : \"\",\n        },\n        {\n          tag: e.version,\n          tooltip: e.installedTimestamp ? `Installed:  ${new Date(e.installedTimestamp).toLocaleString()}` : \"\",\n        },\n      ]}\n      actions={\n        <ActionPanel>\n          <ActionPanel.Section>\n            <OpenExtensionInCursorAction extension={e} />\n            <OpenExtensionInBrowserAction extension={e} />\n          </ActionPanel.Section>\n          <ActionPanel.Section>\n            <Action.CopyToClipboard\n              content={e.id}\n              title=\"Copy Extension Id\"\n              shortcut={{ modifiers: [\"cmd\", \"shift\"], key: \".\" }}\n            />\n            {e.publisherDisplayName && (\n              <Action.CopyToClipboard\n                content={e.publisherDisplayName}\n                title=\"Copy Publisher Name\"\n                shortcut={{ modifiers: [\"cmd\", \"shift\"], key: \",\" }}\n              />\n            )}\n            <Action.Open\n              title=\"Open in Finder\"\n              target={e.fsPath}\n              shortcut={{ modifiers: [\"cmd\", \"shift\"], key: \"f\" }}\n            />\n          </ActionPanel.Section>\n          <ActionPanel.Section>\n            <UninstallExtensionByIDAction extensionID={e.id} afterUninstall={props.reloadExtension} />\n          </ActionPanel.Section>\n        </ActionPanel>\n      }\n    />\n  );\n}\n\nexport default function ExtensionsRootCommand(): JSX.Element {\n  const { extensions, isLoading, error, refresh } = useLocalExtensions();\n  if (error) {\n    showToast({ style: Toast.Style.Failure, title: \"Error\", message: error });\n  }\n  const extensionsSorted = extensions?.sort((a, b) => (a.name < b.name ? -1 : a.name > b.name ? 1 : 0));\n  return (\n    <List isLoading={isLoading} searchBarPlaceholder=\"Search Installed Extensions\">\n      <List.Section title=\"Installed Extensions\" subtitle={`${extensionsSorted?.length}`}>\n        {extensionsSorted?.map((e) => (\n          <ExtensionListItem key={e.id} extension={e} reloadExtension={refresh} />\n        ))}\n      </List.Section>\n    </List>\n  );\n}\n\nexport function useLocalExtensions(): {\n  extensions: Extension[] | undefined;\n  isLoading?: boolean;\n  error?: string;\n  refresh: () => void;\n} {\n  const [isLoading, setIsLoading] = useState(true);\n  const [extensions, setExtensions] = useState<Extension[]>();\n  const [error, setError] = useState<string>();\n  const [date, setDate] = useState(new Date());\n\n  const refresh = () => {\n    setDate(new Date());\n  };\n\n  useEffect(() => {\n    let didUnmount = false;\n    async function fetchCommands() {\n      if (didUnmount) {\n        return;\n      }\n      setIsLoading(true);\n      setError(undefined);\n      try {\n        const exts = await getLocalExtensions();\n        if (!didUnmount) {\n          setExtensions(exts);\n        }\n      } catch (error) {\n        if (!didUnmount) {\n          setError(getErrorMessage(error));\n        }\n      } finally {\n        if (!didUnmount) {\n          setIsLoading(false);\n        }\n      }\n    }\n    fetchCommands();\n    return () => {\n      didUnmount = true;\n    };\n  }, []);\n\n  return { extensions: extensions, isLoading, error, refresh };\n}\n", "import { existsSync } from \"fs\";\nimport { URL } from \"url\";\nimport { isDeepStrictEqual } from \"util\";\nimport {\n  EntryType,\n  EntryLike,\n  FileEntry,\n  FolderEntry,\n  RemoteEntry,\n  WorkspaceEntry,\n  RemoteWorkspaceEntry,\n} from \"./types\";\nimport { open } from \"@raycast/api\";\nimport * as fs from \"fs\";\n\n// Type Guards\n\nexport function isFileEntry(entry: EntryLike): entry is FileEntry {\n  const { fileUri } = entry as FileEntry;\n\n  if (fileUri === undefined) {\n    return false;\n  }\n\n  try {\n    const fileUrl = new URL(fileUri);\n    return existsSync(fileUrl) && fileUri.indexOf(\".code-workspace\") === -1;\n  } catch (error) {\n    return false;\n  }\n}\n\nexport function isFolderEntry(entry: EntryLike): entry is FolderEntry {\n  const { folderUri } = entry as FolderEntry;\n\n  if (folderUri === undefined) {\n    return false;\n  }\n\n  try {\n    const folderUrl = new URL(folderUri);\n    return existsSync(folderUrl);\n  } catch (error) {\n    return false;\n  }\n}\n\nexport function isWorkspaceEntry(entry: EntryLike): entry is WorkspaceEntry {\n  const { workspace } = entry as WorkspaceEntry;\n\n  if (workspace === undefined) {\n    return false;\n  }\n\n  try {\n    const configUrl = new URL(workspace.configPath);\n    return existsSync(configUrl) && workspace.configPath.indexOf(\".code-workspace\") !== -1;\n  } catch (error) {\n    return false;\n  }\n}\n\nexport function isRemoteEntry(entry: EntryLike): entry is RemoteEntry {\n  const { folderUri, remoteAuthority } = entry as RemoteEntry;\n  return folderUri !== undefined && remoteAuthority !== undefined;\n}\n\nexport function isRemoteWorkspaceEntry(entry: EntryLike): entry is RemoteWorkspaceEntry {\n  const { workspace, remoteAuthority } = entry as RemoteWorkspaceEntry;\n  return workspace !== undefined && remoteAuthority !== undefined;\n}\n\nexport function isSameEntry(a: EntryLike, b: EntryLike) {\n  if (\"fileUri\" in a && \"fileUri\" in b) {\n    return a.fileUri === b.fileUri;\n  }\n\n  if (\"folderUri\" in a && \"folderUri\" in b) {\n    return a.folderUri === b.folderUri;\n  }\n\n  if (\"workspace\" in a && \"workspace\" in b) {\n    return a.workspace.configPath === b.workspace.configPath;\n  }\n\n  return false;\n}\n\n// Filters\n\nexport function filterEntriesByType(filter: EntryType | null) {\n  switch (filter) {\n    case \"All Types\":\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      return (entry: EntryLike) => true;\n    case \"Workspaces\":\n      return isWorkspaceEntry;\n    case \"Folders\":\n      return isFolderEntry;\n    case \"Remote Folders\":\n      return isRemoteEntry;\n    case \"Remote Workspace\":\n      return isRemoteWorkspaceEntry;\n    case \"Files\":\n      return isFileEntry;\n    default:\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      return (entry: EntryLike) => false;\n  }\n}\n\nexport function filterUnpinnedEntries(pinnedEntries: EntryLike[]) {\n  return (entry: EntryLike) => pinnedEntries.find((pinnedEntry) => isDeepStrictEqual(pinnedEntry, entry)) === undefined;\n}\n\nexport function getErrorMessage(error: unknown): string {\n  return error instanceof Error ? error.message : \"unknown error\";\n}\n\nexport async function fileExists(filename: string): Promise<boolean> {\n  return fs.promises\n    .access(filename, fs.constants.F_OK)\n    .then(() => true)\n    .catch(() => false);\n}\n\nconst fmt = new Intl.NumberFormat(\"en\", { notation: \"compact\" });\n\nexport function compactNumberFormat(num: number): string {\n  return fmt.format(num);\n}\n\nexport function sleep(ms: number) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\nexport async function waitForFileExists(filename: string, timeoutMs = 2000) {\n  const start = new Date();\n  while (start.getTime() > 0) {\n    await sleep(10);\n    if (await fileExists(filename)) {\n      return true;\n    }\n    const end = new Date();\n    const delta = end.getTime() - start.getTime();\n    if (delta > timeoutMs) {\n      return false;\n    }\n  }\n  return false;\n}\n\nexport function raycastForCursorURI(uri: string) {\n  return `cursor://tonka3000.raycast/${uri}`;\n}\n\nexport async function openURIinCursor(uri: string) {\n  await open(raycastForCursorURI(uri));\n}\n\nexport function isValidHexColor(color: string): boolean {\n  return /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(color);\n}\n", "import { fileExists } from \"../utils\";\nimport * as afs from \"fs/promises\";\nimport * as os from \"os\";\nimport path from \"path\";\nimport * as child_process from \"child_process\";\n\ninterface ExtensionMetaRoot {\n  identifier: ExtensionIdentifier;\n  version: string;\n  location: ExtensionLocation | string;\n  metadata?: ExtensionMetadata;\n}\n\ninterface ExtensionIdentifier {\n  id: string;\n  uuid: string;\n}\n\ninterface ExtensionLocation {\n  $mid: number;\n  fsPath: string;\n  path: string;\n  scheme: string;\n}\n\ninterface ExtensionMetadata {\n  id: string;\n  publisherId?: string;\n  publisherDisplayName?: string;\n  targetPlatform?: string;\n  isApplicationScoped?: boolean;\n  updated?: boolean;\n  isPreReleaseVersion: boolean;\n  installedTimestamp?: number;\n  preRelease?: boolean;\n}\n\nexport interface Extension {\n  id: string;\n  name: string;\n  version: string;\n  preRelease?: boolean;\n  icon?: string;\n  updated?: boolean;\n  fsPath: string;\n  publisherId?: string;\n  publisherDisplayName?: string;\n  preview?: boolean;\n  installedTimestamp?: number;\n}\n\ninterface PackageJSONInfo {\n  displayName?: string;\n  icon?: string;\n  preview?: boolean;\n}\n\nfunction getNLSVariable(text: string | undefined): string | undefined {\n  if (!text) {\n    return text;\n  }\n  const m = text.match(/%(.+)%/);\n  if (m) {\n    return m[1];\n  }\n}\n\nexport function getCursorCLIFilename(): string {\n  return \"/Applications/Cursor.app/Contents/Resources/app/bin/cursor\";\n}\n\nexport class CursorCLI {\n  private cliFilename: string;\n  constructor(cliFilename: string) {\n    this.cliFilename = cliFilename;\n  }\n  installExtensionByIDSync(id: string) {\n    child_process.execFileSync(this.cliFilename, [\"--install-extension\", id, \"--force\"]);\n  }\n  uninstallExtensionByIDSync(id: string) {\n    child_process.execFileSync(this.cliFilename, [\"--uninstall-extension\", id, \"--force\"]);\n  }\n}\n\nexport function getCursorCLI(): CursorCLI {\n  return new CursorCLI(getCursorCLIFilename());\n}\n\nasync function getPackageJSONInfo(filename: string): Promise<PackageJSONInfo | undefined> {\n  try {\n    if (await fileExists(filename)) {\n      const packageJSONData = await afs.readFile(filename, {\n        encoding: \"utf-8\",\n      });\n      const packageJSON = JSON.parse(packageJSONData);\n      let displayName = packageJSON.displayName as string | undefined;\n      const nlsVariable = getNLSVariable(displayName);\n      const iconFilename = packageJSON.icon as string | undefined;\n      const folder = path.dirname(filename);\n      if (nlsVariable && nlsVariable.length > 0) {\n        const nlsFilename = path.join(folder, \"package.nls.json\");\n        try {\n          if (await fileExists(nlsFilename)) {\n            const nlsContent = await afs.readFile(nlsFilename, {\n              encoding: \"utf-8\",\n            });\n            const nlsJSON = JSON.parse(nlsContent);\n            const displayNameNLS = nlsJSON[nlsVariable] as string | undefined;\n            if (displayNameNLS && displayNameNLS.length > 0) {\n              displayName = displayNameNLS;\n            }\n          }\n        } catch (error) {\n          // ignore\n        }\n      }\n      const preview = packageJSON.preview as boolean | undefined;\n      const icon = iconFilename ? path.join(folder, iconFilename) : undefined;\n      return {\n        displayName,\n        icon,\n        preview,\n      };\n    }\n  } catch (error) {\n    //\n  }\n}\n\nexport async function getLocalExtensions(): Promise<Extension[] | undefined> {\n  const extensionsRootFolder = path.join(os.homedir(), \".cursor/extensions\");\n  const extensionsManifrestFilename = path.join(extensionsRootFolder, \"extensions.json\");\n  if (await fileExists(extensionsManifrestFilename)) {\n    const data = await afs.readFile(extensionsManifrestFilename, {\n      encoding: \"utf-8\",\n    });\n    const extensions = JSON.parse(data) as ExtensionMetaRoot[] | undefined;\n    if (extensions && extensions.length > 0) {\n      const result: Extension[] = [];\n      for (const e of extensions) {\n        const extFsPath =\n          typeof e.location === \"string\"\n            ? path.join(extensionsRootFolder, e.location)\n            : e.location.fsPath ?? e.location.path;\n        const packageFilename = path.join(extFsPath, \"package.json\");\n        const pkgInfo = await getPackageJSONInfo(packageFilename);\n        result.push({\n          id: e.identifier.id,\n          name: pkgInfo?.displayName || e.identifier.id,\n          version: e.version,\n          preRelease: e.metadata?.preRelease,\n          icon: pkgInfo?.icon,\n          updated: e.metadata?.updated,\n          fsPath: extFsPath,\n          publisherId: e.metadata?.publisherId,\n          publisherDisplayName: e.metadata?.publisherDisplayName,\n          preview: pkgInfo?.preview,\n          installedTimestamp: e.metadata?.installedTimestamp,\n        });\n      }\n      return result;\n    }\n  }\n  return undefined;\n}\n", "import { showToast, Toast, Action, Icon, Color, confirmAlert, Alert, showHUD } from \"@raycast/api\";\nimport { getCursorCLI } from \"./lib/cursor\";\nimport { getErrorMessage } from \"./utils\";\n\nexport function InstallExtensionByIDAction(props: { extensionID: string; afterInstall?: () => void }): JSX.Element {\n  const handle = async () => {\n    try {\n      await showToast({\n        style: Toast.Style.Animated,\n        title: \"Install Extension\",\n      });\n      const cli = getCursorCLI();\n      cli.installExtensionByIDSync(props.extensionID);\n      await showToast({\n        style: Toast.Style.Success,\n        title: \"Install Successful\",\n      });\n      if (props.afterInstall) {\n        props.afterInstall();\n      }\n    } catch (error) {\n      showToast({\n        style: Toast.Style.Failure,\n        title: \"Error\",\n        message: getErrorMessage(error),\n      });\n    }\n  };\n  return <Action onAction={handle} title=\"Install Extension\" icon={{ source: Icon.Plus }} />;\n}\n\nexport function UninstallExtensionByIDAction(props: { extensionID: string; afterUninstall?: () => void }): JSX.Element {\n  const handle = async () => {\n    try {\n      if (\n        await confirmAlert({\n          title: \"Uninstall Extension?\",\n          icon: { source: Icon.Trash, tintColor: Color.Red },\n          primaryAction: {\n            style: Alert.ActionStyle.Destructive,\n            title: \"Uninstall\",\n          },\n        })\n      ) {\n        await showToast({\n          style: Toast.Style.Animated,\n          title: \"Install Extension\",\n        });\n        const cli = getCursorCLI();\n        cli.uninstallExtensionByIDSync(props.extensionID);\n        await showToast({\n          style: Toast.Style.Success,\n          title: \"Uninstall Successful\",\n        });\n        if (props.afterUninstall) {\n          props.afterUninstall();\n        }\n      }\n    } catch (error) {\n      showToast({\n        style: Toast.Style.Failure,\n        title: \"Error\",\n        message: getErrorMessage(error),\n      });\n    }\n  };\n  return <Action onAction={handle} title=\"Uninstall Extension\" icon={{ source: Icon.Trash, tintColor: Color.Red }} />;\n}\n\nexport function OpenExtensionByIDInCursorAction(props: {\n  extensionID: string;\n  onOpen?: (url: string) => void;\n}): JSX.Element {\n  return (\n    <Action.OpenInBrowser\n      title=\"Open in Cursor\"\n      url={`cursor:extension/${props.extensionID}`}\n      icon={\"icon.png\"}\n      onOpen={(url) => {\n        showHUD(\"Open Cursor Extension\");\n        if (props.onOpen) {\n          props.onOpen(url);\n        }\n      }}\n    />\n  );\n}\n\nexport function OpenExtensionByIDInBrowserAction(props: { extensionID: string }): JSX.Element {\n  const url = `https://marketplace.visualstudio.com/items?itemName=${props.extensionID}`;\n  return (\n    <Action.OpenInBrowser\n      title=\"Open in Browser\"\n      url={url}\n      shortcut={{ modifiers: [\"cmd\"], key: \"b\" }}\n      onOpen={() => {\n        showHUD(\"Open Cursor Extension in Browser\");\n      }}\n    />\n  );\n}\n"],
  "mappings": "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",
  "names": ["extensions_exports", "__export", "ExtensionsRootCommand", "useLocalExtensions", "__toCommonJS", "import_api", "import_react", "import_api", "fs", "getErrorMessage", "error", "fileExists", "filename", "fmt", "afs", "os", "import_path", "child_process", "getNLSVariable", "text", "m", "getCursorCLIFilename", "CursorCLI", "cliFilename", "id", "getCursorCLI", "getPackageJSONInfo", "filename", "fileExists", "packageJSONData", "packageJSON", "displayName", "nlsVariable", "iconFilename", "folder", "path", "nlsFilename", "nlsContent", "displayNameNLS", "preview", "icon", "getLocalExtensions", "extensionsRootFolder", "extensionsManifrestFilename", "data", "extensions", "result", "e", "extFsPath", "packageFilename", "pkgInfo", "import_api", "import_jsx_runtime", "UninstallExtensionByIDAction", "props", "getCursorCLI", "error", "getErrorMessage", "OpenExtensionByIDInCursorAction", "url", "OpenExtensionByIDInBrowserAction", "import_jsx_runtime", "OpenExtensionInCursorAction", "props", "OpenExtensionByIDInCursorAction", "OpenExtensionInBrowserAction", "OpenExtensionByIDInBrowserAction", "ExtensionListItem", "e", "UninstallExtensionByIDAction", "ExtensionsRootCommand", "extensions", "isLoading", "error", "refresh", "useLocalExtensions", "extensionsSorted", "a", "b", "setIsLoading", "setExtensions", "setError", "date", "setDate", "didUnmount", "fetchCommands", "exts", "getLocalExtensions", "getErrorMessage"]
}
